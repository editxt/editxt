# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: groovy.js
name = 'Groovy'
file_patterns = ['*.groovy']

keyword = """
    byte short char int long boolean float double void def as in assert
    trait super this abstract static volatile transient public private
    protected synchronized final class interface enum if else for while
    switch case break default continue throw throws try catch finally
    implements extends new import package return instanceof
    """.split()

literal = ['true', 'false', 'null']

doctag = [RE(r"@[A-Za-z]+")]

doctag0 = [RE(r"(?:TODO|FIXME|NOTE|BUG|XXX):")]

class comment:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': '\\w+@', 'type': 'RegExp'}, 'relevance': 0},
        ('doctag', doctag),
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag0),
    ]

class comment0:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag0),
    ]
comment0.__name__ = 'comment'

class string:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
    ]

class regexp:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
    ]

number = [RE(r"\b(?:0b[01]+)")]

keyword0 = ['class', 'interface', 'trait', 'enum']

title = [RE(r"[a-zA-Z_]\w*")]

class class0:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword0),
        ('_group2', RE(r"\b(?:extends|implements)"), [RE(r"\B\b")]),
        ('title', title),
    ]
class0.__name__ = 'class'

number0 = [
    RE(r"(?:\b0[xX][a-fA-F0-9]+|(?:\b\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?)"),
]

string0 = [RE(r"[^\?]{0}[A-Za-z0-9_$]+ *:")]

symbol = [RE(r"^\s*[A-Za-z0-9_$]+:")]

rules = [
    ('keyword', keyword),
    ('literal', literal),
    ('comment', RE(r"/\*\*"), [RE(r"\*/")], comment),
    ('comment', RE(r"//"), [RE(r"$")], comment0),
    ('comment', RE(r"/\*"), [RE(r"\*/")], comment0),
    ('string', RE(r"\"\"\""), [RE(r"\"\"\"")]),
    ('string', RE(r"'''"), [RE(r"'''")]),
    ('string', RE(r"\$/"), [RE(r"/\$")]),
    ('string', RE(r"'"), [RE(r"'")], string),
    ('regexp', RE(r"~?\/[^\/\n]+\/"), [RE(r"\B\b")], regexp),
    ('string', RE(r"\""), [RE(r"\"")], string),
    ('meta', RE(r"^#!/usr/bin/env"), [RE(r"$")]),
    ('number', number),
    ('class', RE(r"\b(?:class|interface|trait|enum)"), [RE(r"{")], class0),
    ('number', number0),
    ('meta', doctag),
    ('string', string0),
    ('_group3', RE(r"\?"), [RE(r"\:")]),
    ('symbol', symbol),
]

# TODO merge "word_groups" and "delimited_ranges" into "rules" in editxt.syntax
assert "__obj" not in globals()
assert "__fixup" not in globals()
def __fixup(obj):
    groups = []
    ranges = []
    rules = getattr(obj, "rules", [])
    for i, rng in reversed(list(enumerate(rules))):
        if len(rng) == 2:
            groups.append(rng)
        else:
            assert len(rng) > 2, rng
            ranges.append(rng)
    return groups, ranges

class __obj:
    rules = globals().get("rules", [])
word_groups, delimited_ranges = __fixup(__obj)

for __obj in globals().values():
    if hasattr(__obj, "rules"):
        __obj.word_groups, __obj.delimited_ranges = __fixup(__obj)

del __obj, __fixup
