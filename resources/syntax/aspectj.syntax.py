# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: aspectj.js
name = 'AspectJ'
file_patterns = ['*.aspectj']

keyword = """
    false synchronized int abstract float private char boolean static
    null if const for true while long throw strictfp finally protected
    import native final return void enum else extends implements break
    transient new catch instanceof byte super volatile case assert short
    package default double public try this switch continue throws
    privileged aspectOf adviceexecution proceed cflowbelow cflow
    initialization preinitialization staticinitialization withincode
    target within execution getWithinTypeName handler thisJoinPoint
    thisJoinPointStaticPart thisEnclosingJoinPointStaticPart declare
    parents warning error soft precedence thisAspectInstance
    """.split()

doctag = [RE(r"@[A-Za-z]+")]

doctag0 = [RE(r"(?:TODO|FIXME|NOTE|BUG|XXX):")]

class comment:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': '\\w+@', 'type': 'RegExp'}, 'relevance': 0},
        ('doctag', doctag),
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag0),
    ]

class comment0:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag0),
    ]
comment0.__name__ = 'comment'

class string:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
    ]

class _class:
    default_text = DELIMITER
    rules = [('_class', RE(r"[{;=]"), [RE(r'\b|\B')])]

keyword0 = ['aspect']

title = [RE(r"[a-zA-Z_]\w*")]

keyword1 = """
    false synchronized int abstract float private char boolean static
    null if const for true while long throw strictfp finally protected
    import native final return void enum else extends implements break
    transient new catch instanceof byte super volatile case assert short
    package default double public try this switch continue throws
    privileged aspectOf adviceexecution proceed cflowbelow cflow
    initialization preinitialization staticinitialization withincode
    target within execution getWithinTypeName handler thisJoinPoint
    thisJoinPointStaticPart thisEnclosingJoinPointStaticPart declare
    parents warning error soft precedence thisAspectInstance get set
    args call
    """.split()

class _group3:
    default_text = DELIMITER
    rules = [('keyword', keyword1)]

class class0:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword0),
        ('_group2', RE(r"\b(?:extends|implements|pertypewithin|perthis|pertarget|percflowbelow|percflow|issingleton)"), [RE(r"\B\b")]),
        ('title', title),
        ('_group3', RE(r"\([^\)]*"), [RE(r"[)]+")], _group3),
    ]
class0.__name__ = 'class'

keyword2 = ['class', 'interface']

class class1:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword2),
        ('_group4', RE(r"\b(?:extends|implements)"), [RE(r"\B\b")]),
        ('title', title),
    ]
class1.__name__ = 'class'

keyword3 = ['pointcut', 'after', 'before', 'around', 'throwing', 'returning']

class _group6:
    default_text = DELIMITER
    rules = [('title', title)]

class _group5:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword3),
        ('_group6', RE(r"(?=[a-zA-Z_]\w*\s*\()"), [RE(r"\B\b")], _group6),
    ]

class _group8:
    default_text = DELIMITER
    rules = [('keyword', keyword1)]

class _group7:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword),
        ('_group8', RE(r"[a-zA-Z_]\w*\s*\("), [RE(r"\B\b")], _group8),
        None,  # rules[5],
    ]

class _function:
    default_text = DELIMITER
    rules = [('_function', RE(r"[{;=]"), [RE(r'\b|\B')])]

class _group10:
    default_text = DELIMITER
    rules = [('title', title)]

number = [
    RE(r"(?:\b0[xX][a-fA-F0-9]+|(?:\b\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?)"),
]

class params:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword),
        None,  # rules[4],
        None,  # rules[5],
        ('number', number),
        None,  # rules[3],
    ]

class function:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword),
        ('_group10', RE(r"(?=[a-zA-Z_]\w*\s*\()"), [RE(r"\B\b")], _group10),
        ('params', RE(r"\("), [RE(r"\)")], params),
        None,  # rules[2],
        None,  # rules[3],
    ]

rules = [
    ('keyword', keyword),
    ('comment', RE(r"/\*\*"), [RE(r"\*/")], comment),
    ('comment', RE(r"//"), [RE(r"$")], comment0),
    ('comment', RE(r"/\*"), [RE(r"\*/")], comment0),
    ('string', RE(r"'"), [RE(r"'")], string),
    ('string', RE(r"\""), [RE(r"\"")], string),
    ('class', RE(r"\b(?:aspect)"), [_class], class0),
    ('class', RE(r"\b(?:class|interface)"), [_class], class1),
    ('_group5', RE(r"\b(?:pointcut|after|before|around|throwing|returning)"), [RE(r"[)]")], _group5),
    ('_group7', RE(r"(?=[:])"), [RE(r"[{;]")], _group7),
    ('_group9', RE(r"\b(?:new|throw)"), [RE(r"\B\b")]),
    ('function', RE(r"(?=\w+ +\w+(?:\.)?\w+\s*\([^\)]*\)\s*(?:(throws)[\w\s,]+)?[\{;])"), [_function], function),
    ('number', number),
    ('meta', doctag),
]

_group7.rules[2] = rules[5]
params.rules[1] = rules[4]
params.rules[2] = rules[5]
params.rules[4] = rules[3]
function.rules[3] = rules[2]
function.rules[4] = rules[3]

# TODO merge "word_groups" and "delimited_ranges" into "rules" in editxt.syntax
assert "__obj" not in globals()
assert "__fixup" not in globals()
def __fixup(obj):
    groups = []
    ranges = []
    rules = getattr(obj, "rules", [])
    for i, rng in reversed(list(enumerate(rules))):
        if len(rng) == 2:
            groups.append(rng)
        else:
            assert len(rng) > 2, rng
            ranges.append(rng)
    return groups, ranges

class __obj:
    rules = globals().get("rules", [])
word_groups, delimited_ranges = __fixup(__obj)

for __obj in globals().values():
    if hasattr(__obj, "rules"):
        __obj.word_groups, __obj.delimited_ranges = __fixup(__obj)

del __obj, __fixup
