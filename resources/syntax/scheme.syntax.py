# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: scheme.js
name = 'Scheme'
file_patterns = ['*.scheme']

number = ('number', [RE(r"(?:\-|\+)?\d+(?:[./]\d+)?")])

number0 = ('number', [RE(r"(?:\-|\+)?\d+(?:[./]\d+)?[+\-](?:\-|\+)?\d+(?:[./]\d+)?i")])

number1 = ('number', [RE(r"#b[0-1]+(?:/[0-1]+)?")])

number2 = ('number', [RE(r"#o[0-7]+(?:/[0-7]+)?")])

number3 = ('number', [RE(r"#x[0-9a-f]+(?:/[0-9a-f]+)?")])

class string:
    default_text_color = DELIMITER
    rules = [('operator.escape', [RE(r"\\[\s\S]")])]

string0 = ('string', RE(r"\""), [RE(r"\"")], string)

symbol = ('symbol', [RE(r"'[^\(\)\[\]\{\}\",'`;#|\\\s]+")])

builtin_name = """
    case-lambda call/cc class define-class exit-handler field import
    inherit init-field interface let*-values let-values let/ec mixin
    opt-lambda override protect provide public rename require
    require-for-syntax syntax syntax-case syntax-error unit/sig unless
    when with-syntax and begin call-with-current-continuation
    call-with-input-file call-with-output-file case cond define
    define-syntax delay do dynamic-wind else for-each if lambda let let*
    let-syntax letrec letrec-syntax map or syntax-rules ' * + , ,@ - ...
    / ; < <= = => > >= ` abs acos angle append apply asin assoc assq
    assv atan boolean? caar cadr call-with-input-file
    call-with-output-file call-with-values car cdddar cddddr cdr ceiling
    char->integer char-alphabetic? char-ci<=? char-ci<? char-ci=?
    char-ci>=? char-ci>? char-downcase char-lower-case? char-numeric?
    char-ready? char-upcase char-upper-case? char-whitespace? char<=?
    char<? char=? char>=? char>? char? close-input-port
    close-output-port complex? cons cos current-input-port
    current-output-port denominator display eof-object? eq? equal? eqv?
    eval even? exact->inexact exact? exp expt floor force gcd imag-part
    inexact->exact inexact? input-port? integer->char integer?
    interaction-environment lcm length list list->string list->vector
    list-ref list-tail list? load log magnitude make-polar
    make-rectangular make-string make-vector max member memq memv min
    modulo negative? newline not null-environment null? number->string
    number? numerator odd? open-input-file open-output-file output-port?
    pair? peek-char port? positive? procedure? quasiquote quote quotient
    rational? rationalize read read-char real-part real? remainder
    reverse round scheme-report-environment set! set-car! set-cdr! sin
    sqrt string string->list string->number string->symbol string-append
    string-ci<=? string-ci<? string-ci=? string-ci>=? string-ci>?
    string-copy string-fill! string-length string-ref string-set!
    string<=? string<? string=? string>=? string>? string? substring
    symbol->string symbol? tan transcript-off transcript-on truncate
    values vector vector->list vector-fill! vector-length vector-ref
    vector-set! with-input-from-file with-output-to-file write
    write-char zero?
    """.split()

class name0:
    default_text_color = DELIMITER
    rules = [('builtin-name', builtin_name)]
name0.__name__ = 'name'

class comment:
    default_text_color = DELIMITER
    rules = [
        # ignore {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', [RE(r"(?:TODO|FIXME|NOTE|BUG|XXX):")]),
    ]

comment0 = ('comment', RE(r";"), [RE(r"$")], comment)

comment1 = ('comment', RE(r"#\|"), [RE(r"\|#")], comment)

class _group1:
    default_text_color = DELIMITER
    rules = [
        ('literal', [RE(r"(?:#t|#f|#\\[^\(\)\[\]\{\}\",'`;#|\\\s]+|#\\.)")]),
        number,
        number0,
        number1,
        number2,
        number3,
        string0,
        # ignore {'begin': '[^\\(\\)\\[\\]\\{\\}",\'`;#|\\\\\\s]+', 'relevance': 0},
        symbol,
        None, # _group00,
        comment0,
        comment1,
    ]

class _group0:
    default_text_color = DELIMITER
    rules = [
        ('name', RE(r"[^\(\)\[\]\{\}\",'`;#|\\\s]+"), [RE(r"\B\b")], name0),
        ('_group1', RE(r"\B|\b"), [RE(r"\B\b")], _group1),
    ]

_group00 = ('_group0', RE(r"\B|\b"), [RE(r"\B\b")], _group0)

class _group11:
    default_text_color = DELIMITER
    rules = [
        ('literal', [RE(r"(?:#t|#f|#\\[^\(\)\[\]\{\}\",'`;#|\\\s]+|#\\.)")]),
        number,
        number0,
        number1,
        number2,
        number3,
        string0,
        # ignore {'begin': '[^\\(\\)\\[\\]\\{\\}",\'`;#|\\\\\\s]+', 'relevance': 0},
        symbol,
        None, # _group02,
        None, # _group03,
        comment0,
        comment1,
    ]
_group11.__name__ = '_group1'

class _group01:
    default_text_color = DELIMITER
    rules = [
        ('name', RE(r"[^\(\)\[\]\{\}\",'`;#|\\\s]+"), [RE(r"\B\b")], name0),
        ('_group1', RE(r"\B|\b"), [RE(r"\B\b")], _group11),
    ]
_group01.__name__ = '_group0'

_group02 = ('_group0', RE(r"\("), [RE(r"\)")], _group01)

_group03 = ('_group0', RE(r"\["), [RE(r"\]")], _group01)

rules = [
    ('meta', RE(r"^#!"), [RE(r"$")]),
    number,
    number0,
    number1,
    number2,
    number3,
    string0,
    symbol,
    _group02,
    _group03,
    comment0,
    comment1,
]

_group1.rules[8] = _group00
_group11.rules[8] = _group02
_group11.rules[9] = _group03
