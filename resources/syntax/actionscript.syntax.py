# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: actionscript.js
name = 'ActionScript'
file_patterns = ['*.actionscript', '*.as']

keyword = """
    as break case catch class const continue default delete do dynamic
    each else extends final finally for function get if implements
    import in include instanceof interface internal is namespace native
    new override package private protected public return set static
    super switch this throw try typeof use var void while with
    """.split()

literal = ['true', 'false', 'null', 'undefined']

class string:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
    ]

doctag = [RE(r"(?:TODO|FIXME|NOTE|BUG|XXX):")]

class comment:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag),
    ]

number = [
    RE(r"(?:\b0[xX][a-fA-F0-9]+|(?:\b\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?)"),
]

keyword0 = ['package']

title = [RE(r"[a-zA-Z]\w*")]

class class0:
    default_text = DELIMITER
    rules = [('keyword', keyword0), ('title', title)]
class0.__name__ = 'class'

class _class:
    default_text = DELIMITER
    rules = [('_class', RE(r"{"), [RE(r'\b|\B')])]

keyword1 = ['class', 'interface']

class class1:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword1),
        ('_group1', RE(r"\b(?:extends|implements)"), [RE(r"\B\b")]),
        ('title', title),
    ]
class1.__name__ = 'class'

meta_keyword = ['import', 'include']

class meta:
    default_text = DELIMITER
    rules = [('meta-keyword', meta_keyword)]

class _function:
    default_text = DELIMITER
    rules = [('_function', RE(r"[{;]"), [RE(r'\b|\B')])]

keyword2 = ['function']

class params:
    default_text = DELIMITER
    rules = [
        None,  # rules[2],
        None,  # rules[3],
        None,  # rules[4],
        None,  # rules[5],
        ('rest_arg', RE(r"[.]{3}"), [RE(r"[a-zA-Z_$][a-zA-Z0-9_$]*")]),
    ]

class function:
    default_text = DELIMITER
    rules = [
        ('keyword', keyword2),
        ('title', title),
        ('params', RE(r"\("), [RE(r"\)")], params),
        # {'begin': ':\\s*([*]|[a-zA-Z_$][a-zA-Z0-9_$]*)'},
    ]

rules = [
    ('keyword', keyword),
    ('literal', literal),
    ('string', RE(r"'"), [RE(r"'")], string),
    ('string', RE(r"\""), [RE(r"\"")], string),
    ('comment', RE(r"//"), [RE(r"$")], comment),
    ('comment', RE(r"/\*"), [RE(r"\*/")], comment),
    ('number', number),
    ('class', RE(r"\b(?:package)"), [RE(r"{")], class0),
    ('class', RE(r"\b(?:class|interface)"), [_class], class1),
    ('meta', RE(r"\b(?:import|include)"), [RE(r";")], meta),
    ('function', RE(r"\b(?:function)"), [_function], function),
]

params.rules[0] = rules[2]
params.rules[1] = rules[3]
params.rules[2] = rules[4]
params.rules[3] = rules[5]

# TODO merge "word_groups" and "delimited_ranges" into "rules" in editxt.syntax
assert "__obj" not in globals()
assert "__fixup" not in globals()
def __fixup(obj):
    groups = []
    ranges = []
    rules = getattr(obj, "rules", [])
    for i, rng in reversed(list(enumerate(rules))):
        if len(rng) == 2:
            groups.append(rng)
        else:
            assert len(rng) > 2, rng
            ranges.append(rng)
    return groups, ranges

class __obj:
    rules = globals().get("rules", [])
word_groups, delimited_ranges = __fixup(__obj)

for __obj in globals().values():
    if hasattr(__obj, "rules"):
        __obj.word_groups, __obj.delimited_ranges = __fixup(__obj)

del __obj, __fixup
