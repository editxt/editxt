# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: elixir.js
name = 'Elixir'
file_patterns = ['*.elixir']

keyword = """
    and false then defined module in return redo retry end for true self
    when next until do begin unless nil break not case cond alias while
    ensure or include use alias fn quote
    """.split()

class subst:
    default_text = DELIMITER
    rules = [('keyword', keyword)]

class string:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
        ('subst', RE(r"#\{"), [RE(r"}")], subst),
    ]

doctag = [RE(r"(?:TODO|FIXME|NOTE|BUG|XXX):")]

class comment:
    default_text = DELIMITER
    rules = [
        # {'begin': {'pattern': "\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|like)\\b", 'type': 'RegExp'}},
        ('doctag', doctag),
    ]

keyword0 = ['defmodule', 'defrecord']

title = [RE(r"[a-zA-Z_][a-zA-Z0-9_]*(?:\!|\?)?")]

class class0:
    default_text = DELIMITER
    rules = [('keyword', keyword0), ('title', title)]
class0.__name__ = 'class'

keyword1 = ['def', 'defp', 'defmacro']

class function:
    default_text = DELIMITER
    rules = [('keyword', keyword1)]

class symbol:
    default_text = DELIMITER
    rules = [
        None,  # rules[2],
        # {'begin': '[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?'},
    ]

symbol0 = [RE(r"[a-zA-Z_][a-zA-Z0-9_]*(?:\!|\?)?:")]

number = [
    RE(r"(?:\b0[0-7_]+)|(?:\b0x[0-9a-fA-F_]+)|(?:\b[1-9][0-9_]*(?:\.[0-9_]+)?)|[0_]\b"),
]

variable = [RE(r"(?:\$\W)|(?:(\$|\@\@?)(?:\w+))")]

class regexp:
    default_text = DELIMITER
    rules = [
        # {'begin': '\\\\[\\s\\S]', 'relevance': 0},
        string.rules[0],
    ]

class _group2:
    default_text = DELIMITER
    rules = [
        None,  # rules[3],
        ('regexp', RE(r"/"), [RE(r"/[a-z]*")], regexp),
        ('regexp', RE(r"%r\["), [RE(r"\][a-z]*")], regexp),
    ]

rules = [
    ('keyword', keyword),
    ('string', RE(r"'"), [RE(r"'")], string),
    ('string', RE(r"\""), [RE(r"\"")], string),
    ('comment', RE(r"#"), [RE(r"$")], comment),
    ('class', RE(r"\b(?:defmodule|defrecord)"), [RE(r"\bdo\b|$|;")], class0),
    ('function', RE(r"\b(?:def|defp|defmacro)"), [RE(r"\B\b")], function),
    ('symbol', RE(r":"), [RE(r"\B\b")], symbol),
    ('symbol', symbol0),
    ('number', number),
    ('variable', variable),
    # {'begin': '->'},
    ('_group2', RE(r"(?:!|!=|!==|%|%=|&|&&|&=|\*|\*=|\+|\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\?|\[|\{|\(|\^|\^=|\||\|=|\|\||~)\s*"), [RE(r"\B\b")], _group2),
]

symbol.rules[0] = rules[2]
_group2.rules[0] = rules[3]
subst.rules.extend(rules)

# TODO merge "word_groups" and "delimited_ranges" into "rules" in editxt.syntax
assert "__obj" not in globals()
assert "__fixup" not in globals()
def __fixup(obj):
    groups = []
    ranges = []
    rules = getattr(obj, "rules", [])
    for i, rng in reversed(list(enumerate(rules))):
        if len(rng) == 2:
            groups.append(rng)
        else:
            assert len(rng) > 2, rng
            ranges.append(rng)
    return groups, ranges

class __obj:
    rules = globals().get("rules", [])
word_groups, delimited_ranges = __fixup(__obj)

for __obj in globals().values():
    if hasattr(__obj, "rules"):
        __obj.word_groups, __obj.delimited_ranges = __fixup(__obj)

del __obj, __fixup
