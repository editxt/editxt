#! /usr/bin/env python
# EditXT
# Copyright 2007-2013 Daniel Miller <millerdev@gmail.com>
# 
# This file is part of EditXT, a programmer's text editor for Mac OS X,
# which can be found at http://editxt.org/.
# 
# EditXT is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# EditXT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with EditXT.  If not, see <http://www.gnu.org/licenses/>.
"""
Convert Highlight.js syntax definition to EditXT syntax definition

Usage:
    syntaxgen.py [--overwrite] [--ignore=<names>] [-v...] <hljs-file> <editxt-file>
    syntaxgen.py -h | --help

Required arguments:
    <hljs-file>     A language syntax defintion file or directory
                    containing language syntax definition files.
    <editxt-file>   A file or directory where syntax definitions
                    will be written.

Options:
    --overwrite         Overwrite syntax definition if present.
    --ignore=<names>    Comma delimited list of filenames to ignore.
    -v --verbose        Verbose output. (-vv for very verbose)
    -h --help           Show this help screen.

Other useful commands:
    ack -l 'automatically generated by hljs2xt' resources/syntax/ | xargs rm -v
"""
import json
import os
import re
import sys
import traceback
from collections import defaultdict, OrderedDict
from itertools import chain, count
from os.path import abspath, basename, dirname, exists, isdir, isfile, join, splitext
from subprocess import check_output, CalledProcessError

import docopt

THIS_PATH = abspath(dirname(__file__))
HLJS2JSON = join(THIS_PATH, "../resources/hljs2json/hljs2json.js")


def main(args=None):
    opts = docopt.docopt(__doc__, args)
    hljs_file = opts["<hljs-file>"]
    xt_file = opts["<editxt-file>"]
    overwrite = opts["--overwrite"]
    ignore = {i for i in (opts["--ignore"] or "").split(",") if i}
    verbose = opts["--verbose"]
    if isdir(hljs_file):
        for name in os.listdir(hljs_file):
            if name.endswith(".js"):
                hljs_path = join(hljs_file, name)
                if name in ignore:
                    print("IGNORE", hljs_path)
                    continue
                err = convert_syntax(hljs_path, xt_file, overwrite, verbose)
                if err:
                    print(err, hljs_path)
                    #if err != "SKIP":
                    #    sys.exit(1)
    else:
        err = convert_syntax(hljs_file, xt_file, overwrite, verbose)
        if err == "SKIP":
            sys.exit("refusing to overwrite: " + xt_file)
        elif err:
            sys.exit(err + " " + xt_file)


def convert_syntax(hljs_file, xt_file, overwrite, verbose):
    if isdir(xt_file):
        xt_name = splitext(basename(hljs_file))[0] + ".syntax.py"
        xt_file = join(xt_file, xt_name)
    if exists(xt_file) and not overwrite:
        return "SKIP"
    print(hljs_file, "->", xt_file)
    try:
        converted = parse(hljs_file, verbose)
        with open(xt_file, "w", encoding="utf-8") as fh:
            fh.write(converted)
    except CalledProcessError:
        return "ERROR"
    except Exception:
        if verbose:
            traceback.print_exc()
        return "ERROR"


def parse(hljs_file, verbose=False):
    hljs_json = check_output(
        ["node", HLJS2JSON, hljs_file],
        universal_newlines=True
    )
    if verbose > 1:
        print(hljs_json)
    meta = parse_metadata(hljs_file)
    data = DictObj(json.loads(hljs_json))
    definitions = Definitions()
    if data._get("case_insensitive"):
        flags = Assignment("flags", Literal("re.IGNORECASE | re.MULTILINE"))
        flags = definitions.add(flags)
        assert flags == "flags", flags
    syntax = transform_syntax(data, definitions)
    assert not syntax.contains_self, syntax
    assert not syntax.parent_ends, syntax
    aliases = [meta.alias] + data._get("aliases", [])
    return TEMPLATE.format(
        hljs_file=basename(hljs_file),
        name=meta.Language,
        file_patterns=["*." + ext for ext in aliases],
        definitions=definitions,
        word_groups=pretty_format(syntax.words),
        delimited_ranges=pretty_format(syntax.ranges),
    )


def transform_syntax(data, definitions, name=None):
    def add_words(name, value):
        if isinstance(value, str):
            value = [k.split("|")[0] for k in value.split()]
        named = Assignment(name, value)
        ref = definitions.add(named)
        words.append((name, Literal(ref)))
    words = []
    ranges = []
    syntax = SyntaxClass(name, words, ranges)
    keywords = data._get("keywords") or data._get("beginKeywords")
    if keywords:
        if isinstance(keywords, str):
            add_words("keyword", keywords)
        else:
            for name, value in keywords.items():
                add_words(name, value)
    for item in data._get("contains", []):
        if item == "self":
            assert name is not None, repr(syntax)
            syntax.contains_self = True
            continue
        if item.get("type") == "CircularRef":
            raise NotImplementedError
            definitions[tuple(item["path"])]
            continue
        if "variants" in item:
            def iteritems(item):
                for variant in item["variants"]:
                    var = item.copy()
                    var.update(variant)
                    yield var
            items = iteritems(item)
        else:
            items = [item]
        for item in items:
            plain = "className" not in item
            if plain:
                item = dict(item, className=definitions.get_name(item))
            item = DictObj(item, _parent=data)
            if "end" in item or item._get("endsWithParent") \
                    or "contains" in item or "keywords" in item \
                    or "beginKeywords" in item:
                rng = transform_range(item, definitions)
                if item._get("endsParent"):
                    end = SyntaxClass(item.className, [], [rng])
                    end_name = definitions.add(end)
                    syntax.parent_ends.append(Literal(end_name))
                else:
                    ranges.append(rng)
            elif not plain:
                add_words(item.className, [regex(item.begin)])
    return syntax


def transform_range(item, definitions):
    name = item.className

    begin = transform_begin(item)
    end = transform_end(item)

    content = ()
    ends = []
    if "keywords" in item or item._get("contains"):
#        if name in definitions:
#            content = (Literal(name),)
#        else:
        syntax = transform_syntax(item, definitions, name)
        if syntax or syntax.contains_self:
            syntax_name = definitions.add(syntax)
            content = (Literal(syntax_name),)
        ends.extend(syntax.parent_ends)
    if "subLanguage" in item:
        if item._get("subLanguageMode") == "continuous":
            print("continuous sub-language not implemented")
        else:
            assert not content, (name, content)
            if item.subLanguage:
                content = (item.subLanguage,)
            else:
                print("auto sub-language detection not implemented")

    if item._get("starts"):
        start = SyntaxClass(name, [], [(name, begin, [end]) + content])
        start_name = definitions.add(start)
        begin = Literal(start_name)
        end = transform_end(item._parent, lookahead=True)
        if isinstance(item.starts, str):
            content = (Literal(item.starts),)
        else:
            args = {"_parent": item._parent}
            if "className" not in item.starts:
                args["className"] = definitions.get_name(item.starts)
            next_ = DictObj(item.starts, **args)
            sub = transform_syntax(next_, definitions, next_.className)
            sub_name = definitions.add(sub)
            content = (Literal(sub_name),)

    return (name, begin, [end] + ends) + content


def transform_begin(item):
    if "beginKeywords" in item:
        begin = regex(r"\b(" + "|".join(item.beginKeywords.split()) + ")")
    elif "begin" in item:
        begin = regex(item.begin)
    else:
        begin = RE(r"\B|\b")
    if item._get("excludeBegin"):
        # http://highlightjs.readthedocs.org/en/latest/reference.html#excludebegin-excludeend
        pass
    if item._get("returnBegin"):
        begin = RE(r"(?={})".format(begin.pattern))
    return begin


def transform_end(item, lookahead=False):
    if "end" in item and item.end:
        end = regex(item.end)
    elif not item._get("endsWithParent"):
        end = RE(r"\B|\b")
    else:
        end = RE("")
    lookahead = lookahead or (
        end and (item._get("excludeEnd") or item._get("returnEnd"))
    )
# TODO check if highlighting still works correctly without including parent
# end pattern here (I think default behavior for EditXT highlighting is to
# end with parent). This adds an extra "rule0" definition to the css.syntax.py
#    if item._get("endsWithParent") and "end" in item._parent:
#        import bug; bug.trace()
#        if lookahead:
#            end = (end | regex(item._parent.end).non_look_ahead()).look_ahead()
#        else:
#            end = end | regex(item._parent.end).look_ahead()
#    elif lookahead and not end.is_look_ahead():
    if lookahead and not end.is_look_ahead():
        end = end.look_ahead()
    return end


def regex(obj):
    if isinstance(obj, str):
        return RE(obj)
    if obj["type"] == "RegExp":
        return RE(obj["pattern"])
    raise Error("unknown regex type: {}".format(obj))


def recursive_find(item, parent, key):
    if key in item[parent]:
        return item[parent][key]
    return recursive_find(item[parent], parent, key)


def parse_metadata(hljs_file):
    lang = re.compile(r"Language: (.+)$", re.MULTILINE)
    with open(hljs_file, encoding="utf-8") as fh:
        data = fh.read()
    assert "Language" in data
    language = lang.search(data).group(1)
    return DictObj(
        Language=language,
        alias=basename(hljs_file).rsplit(".", 1)[0].lower(),
    )


def pretty_format(obj, indent=0, width=72):
    rep = repr(obj)
    if len(rep) < width - indent:
        return rep
    if type(obj) in ITEM_FORMATS:
        return format_items(obj, indent, width)
    return rep

def format_items(obj, indent, width):
    open, format, close, iteritems = ITEM_FORMATS[type(obj)]
    prefix = " " * indent
    item_prefix = prefix + "    "
    parts = [prefix + open]
    parts.extend(item_prefix + format(i, indent + 4).lstrip() + ","
                 for i in iteritems(obj))
    parts.append(prefix + close)
    return "\n".join(parts)

ITEM_FORMATS = {
    list: ("[", pretty_format, "]", lambda obj: obj),
    #tuple: ("(", pretty_format, ")", lambda obj: obj),
}


class DictObj:

    def __init__(self, _data=None, **data):
        if _data is None:
            _data = data
        elif data:
            _data.update(data)
        self._data = _data

    def __contains__(self, name):
        return name in self._data

    def __getattr__(self, name):
        try:
            return self._data[name]
        except KeyError:
            raise AttributeError("{!r} not in {!r}".format(
                name,
                list(self._data)
            ))

    def __getitem__(self, name):
        return self._data[name]

    def __repr__(self):
        return repr(self._data)

    def _get(self, name, default=None):
        return self._data.get(name, default)


class Definitions:

    def __init__(self):
        self.items = OrderedDict()
        self.names = ("_group{}".format(i) for i in count())

    def add(self, expr):
        name = self.find(expr)
        if name is not None:
            return name
        name = self.get_name(expr, expr.name)
        if name.name != expr.name.name:
            expr.safe_name = name
        self.items[name] = expr
        return name

    def get(self, name, default=None):
        return self.items.get(name, default)

    def get_name(self, value, name=None, exchars=re.compile(r"\W+")):
        if not name:
            return Name(next(self.names), value)
        if isinstance(name, Name):
            name = name.name
        name = exchars.sub("_", name)
        if name[0] in "0123456789":
            name = "_" + name
        temp = name
        number = count()
        while name in self or name in PYTHON_KEYWORDS:
            name = temp + str(next(number))
        return Name(name, value)

    def find(self, obj):
        for name, item in self.items.items():
            if obj == item:
                return name
        return None

    def __contains__(self, name):
        return name in self.items

    #def __getitem__(self, key):
    #    ...

    def __iter__(self):
        return iter(self.items.values())

    def __repr__(self):
        if not self.items:
            return ""
        defs = []
        defined = set()
        deferred = DeferredItems()
        for expr in self.items.values():
            dfr, rep = expr.deferred_repr(defined)
            defs.append(rep)
            defined.add(expr.safe_name)
            deferred.update(dfr)
            deferred_rep = deferred.repr(defined)
            if deferred_rep:
                defs.append(deferred_rep)
        assert not deferred, "unhandled deferreds:\n" + repr(deferred)
        return "\n" + "\n\n".join(defs)


class Name:

    def __init__(self, name, value=None):
        if isinstance(name, Name):
            name = name.name
            assert isinstance(name, str)
        self.name = name
        self.value = value if value is not None else object()

    def __bool__(self):
        return bool(self.name)

    def __eq__(self, other):
        if isinstance(other, str):
            return self.name == other
        return isinstance(other, type(self)) and (
            self.name == other.name or
            self.value == other.value
        )

    def __ne__(self, other):
        return not self == other

    def __hash__(self):
        return hash(self.name)

    def __str__(self):
        return self.name or ""

    def __repr__(self):
        return repr(self.__str__())


class Literal:

    def __init__(self, value):
        self.value = value

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.value == other.value

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        if isinstance(self.value, Name):
            return str(self.value)
        return self.value


class RE:

    def __init__(self, pattern):
        self.pattern = pattern.replace("\n", r"\n").replace("\r", r"\r")

    def __bool__(self):
        return bool(self.pattern)

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.pattern == other.pattern

    def __ne__(self, other):
        return not self == other

    def __or__(self, other):
        if other:
            if not self:
                return other
            return RE(self.pattern + "|" + other.pattern)
        return self

    def __repr__(self):
        return 'RE(r"{}")'.format(self.pattern.replace('"', '\\"'))

    def is_look_ahead(self):
        # WARNING returns wrong result for /(?=\))/
        return self.pattern.startswith("(?=") and self.pattern.endswith(")") \
                and ")" not in self.pattern[3:-1]

    def look_ahead(self):
        return RE(r"(?={})".format(self.pattern))

    def non_look_ahead(self):
        if self.is_look_ahead():
            return RE(self.pattern[3:-1])
        return self


class Assignment:

    def __init__(self, name, value):
        self.safe_name = Name(name, value)
        self.value = value

    @property
    def name(self):
        return self.safe_name

    def deferred_repr(self, defined):
        return DeferredItems(), repr(self)

    def __eq__(self, other):
        return isinstance(other, type(self)) and self.value == other.value

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        return "{} = {}".format(self.safe_name, pretty_format(self.value))


class SyntaxClass:

    def __init__(self, name, words, ranges):
        self.name = Name(name, self)
        self.words = words
        self.ranges = ranges
        self._safe_name = None
        self.contains_self = False
        self.parent_ends = []

    @property
    def safe_name(self):
        return self._safe_name or self.name
    @safe_name.setter
    def safe_name(self, value):
        self._safe_name = value

    def deferred_repr(self, defined):
        items = defaultdict(list)
        for rng in self.ranges:
            names = set()
            for name in self._get_names_from_range(rng):
                if name not in defined:
                    names.add(name)
            if names:
                items[frozenset(names)].append(rng)
        deferred = DeferredItems()
        for names, ranges in items.items():
            deferred.add(names, DeferredRanges(ranges, self))
        return deferred, self.__repr__(deferred)

    @staticmethod
    def _get_names_from_range(rng):
        names = []
        if isinstance(rng[1], Literal):
            names.append(rng[1].value)
        for end in rng[2]:
            if isinstance(end, Literal):
                names.append(end.value)
        if len(rng) > 3 and isinstance(rng[3], Literal):
            names.append(rng[3].value)
        return names

    def __bool__(self):
        return bool(self.words or self.ranges)

    def __eq__(self, other):
        return isinstance(other, type(self)) and (
            #self.name.name == other.name.name and
            self.words == other.words and
            self.ranges == other.ranges
        )

    def __ne__(self, other):
        return not self == other

    def __repr__(self, deferred=None):
        # by design: name == None -> syntax error
        lines = ["class {}:".format(self.safe_name)]
        lines.append("    default_text = DELIMITER")
        if self.words:
            words = pretty_format(self.words, 4).lstrip()
            lines.append("    word_groups = {}".format(words))
        if self.ranges:
            ranges = [r for r in self.ranges if r not in deferred]
            ranges = pretty_format(ranges, 4).lstrip()
            lines.append("    delimited_ranges = {}".format(ranges))
        if self._safe_name:
            lines.append("{}.__name__ = {!r}".format(self.safe_name, self.name))
        return "\n".join(lines)


class DeferredRanges:

    def __init__(self, ranges, syntax):
        self.ranges = ranges
        self.syntax = syntax

    def __contains__(self, value):
        return any(value is r for r in self.ranges)

    def __repr__(self):
        name = self.syntax.safe_name
        if len(self.ranges) == 1:
            return "{}.delimited_ranges.append({})".format(name, self.ranges[0])
        ranges = pretty_format(self.ranges).lstrip()
        return "{}.delimited_ranges.extend({})".format(name, ranges)


class DeferredItems:

    def __init__(self):
        self.items = defaultdict(list)

    def __bool__(self):
        return bool(self.items)

    def add(self, dependent_names, item):
        self.items[dependent_names].append(item)

    def update(self, dfr):
        for key, values in dfr.items.items():
            self.items[key].extend(values)

    def __contains__(self, item):
        return any(item in dfr for dfrs in self.items.values() for dfr in dfrs)

    def repr(self, defined):
        defs = []
        for key in list(self.items):
            if not key - defined:
                defs.extend(repr(v) for v in self.items.pop(key))
        return "\n".join(defs)

    def __repr__(self):
        defs = []
        for values_list in self.items.values():
            for value in values_list:
                defs.append(repr(value))
        return "\n".join(defs)


class Error(Exception): pass


TEMPLATE = """
# -*- coding: UTF-8 -*-
# Syntax definition automatically generated by hljs2xt.py
# source: {hljs_file}
name = {name!r}
file_patterns = {file_patterns!r}
{definitions}

word_groups = {word_groups}

delimited_ranges = {delimited_ranges}
""".lstrip()

PYTHON_KEYWORDS = set("""
    and       del       from      not       while    
    as        elif      global    or        with     
    assert    else      if        pass      yield    
    break     except    import    class     in       
    raise     continue  finally   is        return   
    def       for       lambda    try       nonlocal
    RE        DELIMITER
    comment_token       default_text        delimited_ranges
    disabled  ends      file_patterns       name
    registry  whitespace          word_groups
    """.split())

if __name__ == "__main__":
    main()
